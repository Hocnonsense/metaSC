# -*- coding: utf-8 -*-
"""
 * @Date: 2020-12-28 23:08:55
 * @LastEditors: Hwrn
 * @LastEditTime: 2020-12-29 09:49:51
 * @FilePath: /HScripts/Python/mylib/biotool/meralign.py
 * @Description:
    MUMmer output alignment
"""
from io import StringIO
from mylib.tool.scriptBase import ScriptBase
from mylib.biotool.read_outputs import fasta as read_fasta


class AlignContigs(ScriptBase):
    """To test out the command line parser."""

    def define_parameters(self):
        super(AlignContigs, self).define_parameters()
        self.parser.add_argument(
            'coords',
            help='table of alignment generated by                '
                 '    show-coords -T -q -H <in.delta> > <out.tsv>'
        )
        self.parser.add_argument(
            "fasta",
            help="file path of contig.fa"
                 "or its dict of name and length"
        )
        self.parser.add_argument(
            "out",
            help="output table"
        )
        self.define_option("--name", default="query_seq",
                           help="name of bin", short_name="n")

    def run(self, args):
        print("[AlignContigs] Run args:", args)
        main(args.coords, args.fasta, args.out, args.name)


def read_coords(text: StringIO) -> list:
    """ read out.txt of
            show-coords -T -q -H <in.delta> > <out.txt>
       @return:
            ref_start, ref_end, qry_start, qry_end, ref_len, qry_len, identiy, ref_tag, qry_tag
    """
    coords = []
    for line in text:
        (ref_start, ref_end, qry_start, qry_end,
         ref_len, qry_len, identiy, ref_tag, qry_tag) = line.strip().split()
        coords.append([int(ref_start), int(ref_end),
                       int(qry_start), int(qry_end),
                       int(ref_len), int(qry_len),
                       float(identiy),
                       ref_tag, qry_tag])
    return coords


def main(coords: str, fasta: str, out: str, name: str):
    """ reshape coords by update qry_start and qry_end
        1. read coords_raw into dict-list
        2. sorted by longest match
        3. reverse to fit ref_seq
        4. align
        5. output
    """
    # read fasta
    seqs = read_fasta(fasta)
    contigId_length = {id: len(seq) for id, seq in seqs.items()}
    #print(contigId_length)
    coords_raw = []
    with open(coords) as fi:
        coords_raw = read_coords(fi)
    #print(len(coords_raw), coords_raw[0])

    ## 1. read coords_raw into dict-list
    contigId_matches: dict[str, list] = {}
    for match in coords_raw:
        contigId = match[-1]
        contigId_matches.setdefault(contigId, []).append(match)

    ## 2. sorted by longest match
    for contigId, matches in contigId_matches.items():
        matches.sort(key=lambda match: match[5], reverse=True)
        ## 3. reverse to fit ref_seq
        if matches[0][3] < matches[0][2]:
            length = contigId_length[contigId]
            for match in matches:
                match[2] = length - match[2]
                match[3] = length - match[3]
    ## 2*. sorted again
    contigIds = sorted(contigId_matches,
                       key=lambda contigId: contigId_matches[contigId][0][0]
                       )

    ## 4. align
    coords_align = []
    contig_length = 0
    for contigId in contigIds:
        for match in contigId_matches[contigId]:
            match[2] += contig_length
            match[3] += contig_length
            coords_align.append(match)
        contig_length += contigId_length[contigId]

    ## 5. output
    with open(out, "w") as fo:
        [print(*match, sep="\t", file=fo) for match in coords_align]


if __name__ == "__main__":
    scritps = AlignContigs()
    scritps.cli()
