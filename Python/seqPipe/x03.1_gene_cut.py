# -*- coding: utf-8 -*-
"""
 * @Date: 2020-10-24 10:24:10
 * @Editor: LYX
 * @LastEditors: Hwrn
 * @LastEditTime: 2021-01-03 14:52:25
 * @FilePath: /HScripts/Python/seqPipe/x03.1_gene_cut.py
 * @Description:
        update from LYX's script
    x03.1_gene_cut.py <in_file_prefix> <out_file_prefix> <threshold> [-h] [--help]
        @description:   Remove sequence shorter than given threshold.
                        This file is designed to control quality of
                        prodigal.faa, prodigal.fna, prodigal.gff generated by
                        prodigal.
        @param:         <in_file_prefix>:   input file prefix. For example,
                                        if in_file_prefix is "./M001-prodigal",
                                        then will read these three files:
                                                ./M001-prodigal.faa
                                                ./M001-prodigal.fna
                                                ./M001-prodigal.gff
                                        **NOTE**: "in_file_prefix".faa must
                                        exist.
                        <out_file_prefix>:  output file prefix. Similar to
                                        <in_file_prefix>
                        <threshold>:        threshold for aa, typtically, 33
                                        Any sequence in in_file_prefix.faa but
                                        < threshold will be discarded.
                                        Its record in in_file_prefix.fna and
                                        in_file_prefix.gff will be discarded as
                                        well.
"""

import os
from sys import argv, stderr
from Bio import SeqIO


class prefix_files:
    def __init__(self, prefix) -> None:
        self.prefix = os.path.abspath(os.path.expanduser(prefix))

    def __call__(self, suffix: str, check_exist: bool = None) -> str:
        """
           @param {check_exist: bool}:
                True: return False if file not exist
                False: return False if file exist
                None: do not check
        """
        file_name = self.prefix + suffix

        if os.path.isdir(file_name):
            raise IsADirectoryError
        if check_exist is None or check_exist is os.path.isfile(file_name):
            return file_name

        return False


def parse_args():
    if "-h" in argv or "--help" in argv or len(argv) == 1:
        exit(0)

    sc, in_file_prefix, out_file_prefix, number = argv
    in_file_prefix = prefix_files(in_file_prefix)
    out_file_prefix = prefix_files(out_file_prefix)
    num = int(number)
    args = in_file_prefix, out_file_prefix, num
    print(sc, *args, sep="\n" + " " * 4, file=stderr)
    return args


def main(in_file_prefix, out_file_prefix, num):
    #for (in_file, out_file, num, func) in args:
    #    with open(out_file, "w") as fo \
    #            , open(in_file) as fi \
    #            :
    #        discard_seqs, discard_bases = func(fi, fo, num)
    #    print("    {seqs_n} seqs ({aas_n} aa) are discarded".format(
    #        seqs_n=discard_seqs, aas_n=discard_aas), file=stderr)

    genes_to_trim = {}
    suffix = ".faa"
    in_file = in_file_prefix(suffix, True)
    out_file = out_file_prefix(suffix)
    print("read", in_file, "and write to", out_file, file=stderr)
    if in_file:
        with open(in_file) as fin \
                , open(out_file, 'w') as fout \
                :
            total_trimmed_genes, total_trimmed_aas = 0, 0
            for record in SeqIO.parse(fin, 'fasta'):
                seq = str(record.seq)
                seq_len = len(seq)
                if len(seq) >= num:
                    total_trimmed_genes += 1
                    total_trimmed_aas += seq_len

                    des = str(record.description)
                    print('>' + des, file=fout)
                    print(seq, file=fout)
                else:
                    sid = str(record.id)
                    genes_to_trim[sid] = seq_len

            print("    {seqs_n} seqs ({aas_n} aa) are discarded".format(
                seqs_n=len(genes_to_trim), aas_n=sum(genes_to_trim.values())), file=stderr)
            print("    resulted in {seqs_n} seqs ({aas_n} bases(aa))".format(
                seqs_n=total_trimmed_genes, aas_n=total_trimmed_aas), file=stderr)
    else:
        print("invalid", suffix, "file:", in_file, file=stderr)
        exit(1)

    suffix = ".fna"
    in_file = in_file_prefix(suffix, True)
    out_file = out_file_prefix(suffix)
    print("read", in_file, "and write to", out_file, file=stderr)
    if in_file:
        #check_genes_to_trim = genes_to_trim.copy()
        with open(in_file) as fin \
                , open(out_file, 'w') as fout \
                :
            for record in SeqIO.parse(fin, 'fasta'):
                sid = str(record.id)
                if sid in genes_to_trim:
                    #check_genes_to_trim.pop(sid)
                    continue
                seq = str(record.seq)
                des = str(record.description)
                print('>' + des, file=fout)
                print(seq, file=fout)

    else:
        print("    {in_file} no found, pass".format(in_file=in_file_prefix(suffix)))

    exit

    suffix = ".gff"
    in_file = in_file_prefix(suffix, True)
    out_file = out_file_prefix(suffix)
    print("read", in_file, "and write to", out_file, file=stderr)
    if in_file:
        #check_genes_to_trim = genes_to_trim.copy()
        with open(in_file) as fin \
                , open(out_file, 'w') as fout \
                :
            for line in fin:
                if line[0] == '#':
                    continue
                temp = line.strip().split('\t')
                scaffold = temp[0]
                s_count = temp[8].split(';')[0].split('_')[1]
                sid = scaffold + '_' + s_count
                if sid not in genes_to_trim:
                    fout.write(line)

    else:
        print("    {in_file} no found, pass".format(in_file=in_file_prefix(suffix)))


print(__doc__, file=stderr)

if __name__ == "__main__":
    main(*parse_args())
